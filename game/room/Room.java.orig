package game.room;


import game.GameStats;
import game.controls.Controllable;
import game.draw.GraphicIndicators;
<<<<<<< HEAD
import game.object.spawner.Spawner;
import game.objects.Device;
import game.objects.Explosion;
=======
>>>>>>> 6a41e58e26fa4f475bd008701e266147492018de
import game.objects.GameObject;
import game.objects.Player;
import game.objects.items.Explosion;
import game.objects.items.Mine;
import game.objects.spawner.Spawner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;

public class Room implements Controllable
{
	/* Background */
	private Sprite background;
	
	private Sprite deathRing;
	
	/* Objects */
	private ArrayList<GameObject> objects = new ArrayList<GameObject>();
	private HashSet<GameObject> spawn = new HashSet<GameObject>();
	private ArrayList<GameObject> drops = new ArrayList<GameObject>();
	private Player player;
	private GameObject device;
	public int monsterCount;
	public GameStats stats;
	
	/* Health */
	private Sprite HPBar = new Sprite(new Texture("data/HPBar.png"));
	private Sprite HPFill = new Sprite(new Texture("data/UI/HPFill.png"));
	
	/* Indicators */
	private GraphicIndicators indicators;
	
	/* Wipe */
	private boolean isWiping = false;
	private float wipe = 0;
	private float wipeFade = 0;

	/* Constructor */
	public Room(Texture background, Texture indicators, Texture deathRing, Player player, GameStats stats)
	{
		this.background = new Sprite(background);
		this.deathRing = new Sprite(deathRing);
		this.player = player;
		this.stats = stats;
		this.indicators = new GraphicIndicators(indicators, player);
	}//END Room
	
	/* Object Management */
	/**
	 * Adds an object to the Room's list of objects.
	 * 
	 * @param obj the object to add
	 */
	public void add_object(GameObject obj)
	{
		this.objects.add(obj);
		if(obj.getID() == 1)
		{
			this.indicators.initialize_device(obj);
			this.device = obj;
		}//fi
	}//END add_object
	
	
	public void addDrop(GameObject obj){
		this.drops.add(obj);
	}
	/**
	 * Adds an object to the Room's list of objects to spawn.
	 * 
	 * @param obj the object to add
	 */
	public void spawn_object(GameObject obj)
	{
		this.spawn.add(obj);
	}//END spawn_object
	
	/* Input */
	@Override
	public void input_touchDown(float x, float y, int pointer, int button)
	{
		if(x > 85){
			return;
		}
		
		Iterator<GameObject> iter = this.objects.iterator();
		
		GameObject target = null;
		while(iter.hasNext())
		{
			GameObject obj = iter.next();
			boolean touchedObject = obj.touch(x, y);
			if(touchedObject && (target == null || obj.get_position().dst(x,y) < target.get_position().dst(x,y)))
			{
				target = obj;
			}//fi
		}//elihw
		this.player.input_touchDown(x, y, pointer, button, target);
	}//END input_touch
	
	@Override
	public void input_touchUp(float x, float y, int pointer, int button)
	{	
		this.player.input_touchUp(x, y, pointer, button);
	}//END input_touchUp
	
	@Override
	public void input_touchDrag(float x, float y, int pointer)
	{
		if(x > 85){
			return;
		}
		this.player.input_touchDrag(x, y, pointer);
	}//END input_touchUp
	
	/* Update */
	/**
	 * Updates all the objects in the room.
	 * 
	 * @param dt the difference in time between this and the last cycle
	 */
	public boolean update(float dt)
	{
		monsterCount = objects.size() - 2;
		boolean gameIsLost = true;
		
		/* Spawn Objects */
		Iterator<GameObject> iter = this.spawn.iterator();
		while(iter.hasNext())
		{
			GameObject obj = iter.next();
			if(obj.getID() == 2)
			{
				gameIsLost = false;
				stats.setBoxHP(obj.getHp());
			}//fi
			this.objects.add(obj);
			iter.remove();
		}//elihw
		
		/* Update Indicators */
		this.indicators.update(dt);
		
		/* Update Objects */
		iter = this.objects.iterator();
		while(iter.hasNext())
		{
			GameObject obj = iter.next();
			obj.update(dt, this.objects);
			obj.endUpdate();				
			if(obj.isGone())
			{
				if(obj.getID() == 2){
					
				}
				if(obj.getID() == 3){
					double roll = Math.random();
					if(roll <= 1){
						drops.add(new Mine(99, obj.get_positionX(), stats));
					}
				}
				if(obj.getID() == 97){
					drops.add(new Explosion(obj.get_positionX(), obj.get_positionY()));
				}
				
				iter.remove();
			}//fi			
		}//elihw
		for(GameObject obj : drops){
			objects.add(obj);
		}
		drops = new ArrayList<GameObject>();
		
		if(this.wipe > 0)
		{
			this.wipe -= dt;
		}//fi
		else if(isWiping)
		{
			this.wipe_dmg();
			this.isWiping = false;
		}//fi esle
		else if(this.wipeFade > 0)
		{
			this.wipeFade -= dt;
		}//fi esle
		
		return gameIsLost;
	}//END Update
	
	/* Draw */
	public void render(SpriteBatch spritebatch, float[] renderInfo)
	{
		float current;
		float max;
		//Render Background
		this.background.setSize(renderInfo[2] * (100),
				renderInfo[2] * (62.5f));
		this.background.draw(spritebatch);
		
		//Render Indicator
		this.indicators.render(spritebatch, renderInfo);
		
		//Render Objects
		Collections.sort(this.objects);
		
		Iterator<GameObject> iter = this.objects.iterator();
		while(iter.hasNext())
		{
			GameObject obj = iter.next();
			obj.render(spritebatch, renderInfo);
			
			current = obj.get_healthAttribute().current;
			max = obj.get_healthAttribute().max;
			
			float drawWidth = 5;
			float drawHeight = 1;
			
			if (current != max)
			{
				HPFill.setOrigin((current/max) * renderInfo[2] * (drawWidth/2),
						renderInfo[2] * (drawHeight/2));
				HPFill.setSize((current/max) * renderInfo[2] * (drawWidth),
						5);
				HPFill.setPosition(renderInfo[2] * (obj.get_positionX() - drawWidth/2),
						renderInfo[2] * (obj.get_positionY() - drawHeight/2  + obj.get_hitHeight()));
				HPFill.draw(spritebatch);
				
				HPBar.setOrigin(renderInfo[2] * (drawWidth/2),
						renderInfo[2] * (drawHeight/2));
				HPBar.setSize(renderInfo[2] * (drawWidth),
						renderInfo[2] * (drawHeight));
				HPBar.setPosition(renderInfo[2] * (obj.get_positionX() - drawWidth/2),
						renderInfo[2] * (obj.get_positionY() - drawHeight/2  + obj.get_hitHeight()));
				HPBar.draw(spritebatch);
				
			}
		}//elihw
		
		if(this.isWiping || this.wipeFade > 0)
		{
			float drawWidth = 300-300*this.wipe;
			float drawHeight = 300-300*this.wipe;
			
			this.deathRing.setOrigin(renderInfo[2] * (drawWidth/2),
					renderInfo[2] * (drawHeight/2));
			this.deathRing.setSize(renderInfo[2] * (drawWidth),
					renderInfo[2] * (drawHeight));
			this.deathRing.setPosition(renderInfo[2] * (this.device.get_positionX() - drawWidth/2),
					renderInfo[2] * (this.device.get_positionY() - drawHeight/2));
			this.deathRing.draw(spritebatch, 2*this.wipeFade);
		}//fi
	}//END render
	
	/* Wipe */
	private void wipe()
	{
		this.wipe = 1;
		this.wipeFade = 0.5f;
		this.isWiping = true;
	}//END wipe
	
	private void wipe_dmg()
	{
		Iterator<GameObject> iter = this.objects.iterator();
		while(iter.hasNext())
		{
			GameObject obj = iter.next();
			if(obj.getID() == 3)
			{
				obj.setHp(obj.getHp() - 10);
			}//fi
			if(obj.getID() == 2)
			{
				obj.terminate();
			}//fi
		}//elihw
	}//END wipe
}
